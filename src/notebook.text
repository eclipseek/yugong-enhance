启动流程：入口：YuGongLauncher.java

-> 加载配置到 PropertiesConfiguration 对象
-> 创建并启动全局控制器：YuGongController
   -> 清理 MDC 日志记录信息
   -> 设置启动状态（YuGongLifeCycle）
   -> 启动数据源（DataSourceFactory.start: makeComputingMap）
   -> 加载配置属性到全局控制器
   -> 初始化全局 context
   -> 初始化邮件服务
   -> 初始化要同步的表（Collection<TableHolder>）
   -> 初始化 TableController
      -> 包含一个基于同步表个数的 CountDownLatch
      -> 包含一个基于并发线程个数的 Semaphore
      -> 包含一个缓存已完成同步任务（YuGongInstance）的 BlockingQueue
   -> 初始化进度跟踪器（ProgressTracer）
   -> 初始化用于所有 extractor 共享的全局 ThreadPoolExecutor
   ->
-> 设置虚拟机退出时的 Hook，做清理工作
-> 主线程在全局控制器上挂起，以等待任务结束



***************************************************************************************************************************
1. guava 中 MapMaker$ComputingMapAdapter 的用法
***************************************************************************************************************************
DataSourceFactory 中：
Map<DataSourceConfig, DataSource> dataSources = MigrateMap.makeComputingMap(new Function<DataSourceConfig, DataSource>() {
        public DataSource apply(DataSourceConfig config) {
        return createDataSource(config.getUrl(),
            config.getUsername(),
            config.getPassword(),
            config.getType(),
            config.getProperties());
        }
});

dataSources 是一个 MapMaker$ComputingMapAdapter 类型的 Map，这个 Map 和平时用的 HashMap 不同之处是，在没有 put 一个key 为 x 的元素前
提下，调用该 Map 的 get 方法，将执行一次指定 Function.applay 的计算（如上 Function.applay）得到 value 值，再将键值对 put 到 map。

Function 可自定义，applay 扩展性得以体现。

另外，yugong 之所以单独写一个 com.google.common.collect.MigrateMap，是为了和 guava 的 MapMaker 类路径保持一致，否则无法访问其中某些方法。
这可能是 guava 为了安全感考虑，强制要求客户端必须这样做。

注：有时间好好研究下 guava 的源码。

----------------------------------
使用场景：
缓存刷新，延迟加载，动态加载；
特别是在 value 对 key 有强依赖的场景下。

测试用例：guava.ComputingMapTest.java
----------------------------------

***************************************************************************************************************************
2. YuGongController 中 MDC 的用法
***************************************************************************************************************************
代码位置：YuGongController.java
MDC.remove(YuGongConstants.MDC_TABLE_SHIT_KEY);

MDC（Mapped Diagnostic Context，映射调试上下文）是 log4j 和 logback 提供的一种方便在多线程条件下记录日志的功能。
某些应用程序采用多线程的方式来处理多个用户的请求。在一个用户的使用过程中，可能有多个不同的线程来进行 处理。典型的例子是
Web 应用服务器。当用户访问某个页面时，应用服务器可能会创建一个新的线程来处理该请求，也可能从线程池中复用已有的线程。
在一个用户的会话存续期间，可能有 多个线程处理过该用户的请求。这使得比较难以区分不同用户所对应的日志。当需要追踪某个用户
在系统中的相关日志记录时，就会变得很麻烦。

一种解决的办法是采用自定义的日志格式，把用户的信息采用某种方式编码在日志记录中。这种方式的问题在于要求在每个使用日志记录器的类中，都可以访问到用
户相关的信息。这样才可能在记录日志时使用。这样的条件通常是比较难以满足的。MDC 的作用是解决这个问题。

MDC 可以看成是一个与当前线程绑定的哈希表，可以往其中添加键值对。MDC 中包含的内容可以被同一线程中执行的代码所访问。当前线程的子线程会继承其父线
程中的 MDC 的内容。当需要记录日志时，只需要从 MDC 中获取所需的信息即可。MDC 的内容则由程序在适当的时候保存进去。对于一个 Web 应用来说，通常是
在请求被处理的最开始保存这些数据。


详情见为知笔记：MDC（org.slf4j.MDC）

----------------------------------
使用场景：
并发执行时，线程内部信息分离；
日志输出；
用户信息保存；

测试用例：mdc.MDCTest.java
----------------------------------

***************************************************************************************************************************
3. Runtime.getRuntime().addShutdownHook
***************************************************************************************************************************
JDK 1.6 对该方法的说明：

注册新的虚拟机来关闭钩子。
Java 虚拟机会为了响应以下两类事件而关闭：

程序正常退出，这发生在最后的非守护线程退出时，或者在调用 exit（等同于 System.exit）方法时。或者，

为响应用户中断而终止 虚拟机，如键入 ^C；或发生系统事件，比如用户注销或系统关闭。
关闭钩子 只是一个已初始化但尚未启动的线程。虚拟机开始启用其关闭序列时，它会以某种未指定的顺序启动所有已注册的关闭钩子，并让它们同时运行。运行完
所有的钩子后，如果已启用退出终结，那么虚拟机接着会运行所有未调用的终结方法。最后，虚拟机会暂停。注意，关闭序列期间会继续运行守护线程，如果通过调
用 exit 方法来发起关闭序列，那么也会继续运行非守护线程。

一旦开始了关闭序列，则只能通过调用 halt 方法来停止这个序列，此方法可强行终止虚拟机。

一旦开始了关闭序列，则不可能注册新的关闭钩子或取消注册先前已注册的钩子。尝试执行这些操作会导致抛出 IllegalStateException。

关闭钩子可在虚拟机生命周期中的特定时间运行，因此应保护性地对其进行编码。特别是应将关闭钩子编写为线程安全的，并尽可能地避免死锁。关闭钩子还应该不
盲目地依靠某些服务，这些服务可能已注册了自己的关闭钩子，所以其本身可能正处于关闭进程中。例如，试图使用其他基于线程的服务（如 AWT 事件指派线程）
可能导致死锁。

关闭钩子应该快速地完成其工作。当程序调用 exit 时，虚拟机应该迅速地关闭并退出。由于用户注销或系统关闭而终止虚拟机时，底层的操作系统可能只允许在
固定的时间内关闭并退出。因此在关闭钩子中尝试进行任何用户交互或执行长时间的计算都是不明智的。

与其他所有线程一样，通过调用线程 ThreadGroup 对象的 uncaughtException 方法，可在关闭钩子中处理未捕获的异常。此方法的默认实现是将该异常的堆
栈跟踪打印至 System.err 并终止线程；它不会导致虚拟机退出或暂停。

仅在很少的情况下，虚拟机可能会中止，也就是没有完全关闭就停止运行。虚拟机被外部终止时会出现这种现象，比如在 Unix 上使用 SIGKILL 信号或者在
Microsoft Windows 上调用 TerminateProcess。如果由于内部数据结构损坏或试图访问不存在的内存而导致本机方法执行错误，那么可能也会中止虚拟机。
如果虚拟机中止，则无法保证是否将运行关闭钩子。

----------------------------------
使用场景：在虚拟机退出时做一些收尾工作。
----------------------------------

***************************************************************************************************************************
4. 使用控制接口：LifeCycle
***************************************************************************************************************************
YuGong 中定义了生命周期接口：YuGongLifeCycle，包括启动，停止，异常时终止处理等接口。
重点关注异常终止接口：
public void abort(String why, Throwable e) {
    logger.error("abort caused by " + why, e);
    stop();
}
stop 方法将运行状态 running 设置为 false，程序中关键业务逻辑执行前，会检测该状态，发现为 false，不再执行。

----------------------------------
使用场景：
状态控制；
核心业务逻辑控制等。
----------------------------------


***************************************************************************************************************************
5. 邮件发送系统
***************************************************************************************************************************
位置：MailAlarmService.java

该程序封装了 Spring 中的邮件系统（org.springframework.mail.javamail.xxx）。

核心类：
JavaMailSender：邮件发送者，类似于邮递员；
SimpleMailMessage：邮件信息，类似于信封和其中的内容；



***************************************************************************************************************************
6. ThreadPoolExecutor 的使用
***************************************************************************************************************************
代码位置：YuGongController.start 方法：



***************************************************************************************************************************
* StringUtils.EMPTY： 尽量使用这种方式获取空字符串；
* 使用 MessageFormat.format 执行字符串的格式化操作；
* thresold 常用于表示阈值；
***************************************************************************************************************************